---
title: "Analysis of cell cycle dynamics using revelio"
author:
   - Matthieu Moreau^[Institute of Psychiatry and Neuroscience of Paris, INSERM U1266, 75014, Paris, France, matthieu.moreau@inserm.fr] [![](https://orcid.org/sites/default/files/images/orcid_16x16.png)](https://orcid.org/0000-0002-2592-2373)
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document: 
    code_download: yes
    df_print: tibble
    highlight: haddock
    theme: cosmo
    css: "../style.css"
    toc: yes
    toc_depth: 5
    toc_float:
      collapsed: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align = 'center', message=FALSE, warning=FALSE)

# To use biomart 
new_config <- httr::config(ssl_verifypeer = FALSE)
httr::set_config(new_config, override = FALSE)
```

In this part of the analysis we apply [Revelio](https://github.com/danielschw188/Revelio) algorithm to explore cell cycle dynamic in progenitors and along ChP differentiation

# Load libraries

```{r message=FALSE, warning=FALSE}
library(Seurat)
library(Revelio)
library(orthologsBioMART)
library(Matrix)
library(dplyr)
library(RColorBrewer)
library(ggplot2)
library(ggExtra)
library(cowplot)
library(wesanderson)

#Set ggplot theme as classic
theme_set(theme_classic())
```

# Load and filter progenitors data

```{r}
Hem.data <- readRDS("../QC.filtered.cells.RDS")
```

```{r}
DimPlot(object = Hem.data,
        group.by = "Cell_ident",
        reduction = "spring",
        cols = c("#83c3b8", #"ChP"
                 "#009fda", #"ChP_progenitors"
                 "#68b041", #"Dorso-Medial_pallium"
                 "#e46b6b", #"Hem"
                 "#e3c148", #"Medial_pallium"
                 "#b7d174", #2
                 "grey40", #4
                 "black", #5
                 "#3e69ac" #"Thalamic_eminence"
                 ))
```
We first test the tool on the hem progenitor subset

```{r}
Idents(Hem.data) <- Hem.data$Cell_ident
```


```{r}
Progenitors.data <-  subset(Hem.data, idents = c("Dorso-Medial_pallium","Medial_pallium"))

DimPlot(Progenitors.data,
        reduction = "spring",
        pt.size = 2,
        cols =  c("#68b041","#e3c148")) + NoLegend() & NoAxes()
```

# Prepare data for revelio input

## Find mous ortologues to provided human cell cycle genes

```{r}
Cellcyclegenes <- revelioTestData_cyclicGenes
head(Cellcyclegenes)
```

We use [orthologsBioMART](https://vitkl.github.io/orthologsBioMART/index.html) library to map human to mouse mouse orthologs

```{r}
G1.S <- findOrthologsHsMm(from_filters = "hgnc_symbol",
                          from_values = as.character(Cellcyclegenes$G1.S), 
                          to_attributes = "external_gene_name")

S <- findOrthologsHsMm(from_filters = "hgnc_symbol",
                          from_values = as.character(Cellcyclegenes$S), 
                          to_attributes = "external_gene_name")

G2 <- findOrthologsHsMm(from_filters = "hgnc_symbol",
                          from_values = as.character(Cellcyclegenes$G2), 
                          to_attributes = "external_gene_name")

G2.M <- findOrthologsHsMm(from_filters = "hgnc_symbol",
                          from_values = as.character(Cellcyclegenes$G2.M), 
                          to_attributes = "external_gene_name")

M.G1 <- findOrthologsHsMm(from_filters = "hgnc_symbol",
                          from_values = as.character(Cellcyclegenes$M.G1), 
                          to_attributes = "external_gene_name")


gene.list <- list(G1.S$external_gene_name,
                  S$external_gene_name,
                  G2$external_gene_name,
                  G2.M$external_gene_name,
                  M.G1$external_gene_name)

CCgenes <- t(plyr::ldply(gene.list, rbind))

colnames(CCgenes) <- colnames(Cellcyclegenes)
```


## Export counts matrix

```{r}
rawCounts <- as.matrix(Progenitors.data[["RNA"]]@counts)
```

```{r}
# Filter genes expressed by less than 10 cells
num.cells <- Matrix::rowSums(rawCounts > 0)
genes.use <- names(x = num.cells[which(x = num.cells >= 10)])
rawCounts <- rawCounts[genes.use, ]
```

```{r}
rm(list = ls()[!ls() %in% c("rawCounts", "CCgenes", "Progenitors.data")])
gc()
```

# Run Revelio


We can now follow the tutorial form the [package github page](https://github.com/danielschw188/Revelio) 

```{r}
myData <- createRevelioObject(rawData = rawCounts,
                              cyclicGenes = CCgenes,
                              lowernGeneCutoff = 0,
                              uppernUMICutoff = Inf,
                              ccPhaseAssignBasedOnIndividualBatches = F)
```

The `getCellCyclePhaseAssignInformation` filter "outlier" cells for cell cycle phase assignation. We modified the function to keep all cells as we observed this does not affect the global cell cycle fitting procedure


```{r}
source("../Functions/functions_InitializationCCPhaseAssignFiltering.R")

myData <- getCellCyclePhaseAssign_allcells(myData)
```
```{r}
rm(list = ls()[!ls() %in% c("Progenitors.data", "myData")])
gc()
```

```{r}
Revelio.phase <- as.factor(sapply(Progenitors.data$Barcodes,
                                           function(x) {
                                             if (x %in% myData@cellInfo$cellID) {
                                               x = as.character(myData@cellInfo[x,"ccPhase"])
                                             } else {x = "Outlier"}
                                             }))

levels(Revelio.phase) <- c("G1.S", "S", "G2", "G2.M", "M.G1","Outlier")

Progenitors.data$Revelio.phase <- Revelio.phase

table(Progenitors.data$Revelio.phase)

DimPlot(object = Progenitors.data,
        group.by = "Revelio.phase",
        reduction = "spring",
        cols =  c(wes_palette("FantasticFox1"),"grey90"),
        split.by = 'Revelio.phase')
```


```{r}
myData <- getPCAData(dataList = myData)
myData <- getOptimalRotation(dataList = myData)
```
# Compare results between different ordering approched applied to the DC space

```{r}
CellCycledata <- cbind(as.data.frame(t(myData@transformedData$dc$data[1:2,])),
                       ccPhase = factor(myData@cellInfo$ccPhase, levels = c("G1.S", "S", "G2", "G2.M", "M.G1")),
                       nUMI= myData@cellInfo$nUMI,
                       ccPercent= myData@cellInfo$ccPercentageUniformlySpaced,
                       Seurat.ccScore= Progenitors.data@meta.data[myData@cellInfo$cellID,"CC.Difference"])

CellCycledata$Cycling.Score <- atan2(CellCycledata$DC1, CellCycledata$DC2) / 2 / pi + .5


p1 <- ggplot(CellCycledata, aes(DC1, DC2)) +
        geom_point(aes(color = ccPhase)) +
        scale_color_manual(values= c(wes_palette("FantasticFox1")[1:3],"grey40",wes_palette("FantasticFox1")[5]))

p2 <- ggplot(CellCycledata, aes(DC1, DC2)) +
        geom_point(aes(color=ccPercent), size=2, shape=16) + 
        scale_color_gradientn(colours=rev(colorRampPalette(brewer.pal(n =11, name = "Spectral"))(100)),
                              name='Revelio_ccPercent')

p3 <- ggplot(CellCycledata, aes(DC1, DC2)) +
        geom_point(aes(color=Cycling.Score), size=2, shape=16) + 
        scale_color_gradientn(colours=rev(colorRampPalette(brewer.pal(n =11, name = "Spectral"))(100)),
                              name='Angle_Cycling.Score')

p4 <- ggplot(CellCycledata, aes(DC1, DC2)) +
        geom_point(aes(color=Seurat.ccScore), size=2, shape=16) + 
        scale_color_gradientn(colours=rev(colorRampPalette(brewer.pal(n =11, name = "Spectral"))(100)),
                              name='Seurat_ccDiff')

(p1+p2)/(p3+p4)
```


```{r}
p1 <- ggplot(CellCycledata, aes(x=ccPercent, y = ccPhase, fill= ccPhase)) +
        ggridges::geom_density_ridges() +
        scale_fill_manual(values= c(wes_palette("FantasticFox1")[1:3],"grey40",wes_palette("FantasticFox1")[5]))

p2 <- ggplot(CellCycledata, aes(x=Cycling.Score, y = ccPhase, fill= ccPhase)) +
        ggridges::geom_density_ridges() +
        scale_fill_manual(values= c(wes_palette("FantasticFox1")[1:3],"grey40",wes_palette("FantasticFox1")[5]))

p1/p2
```

```{r}
meanUMI <-c()
for (i in seq(0.05,1, by = 0.05)) {
  UMI <- median(CellCycledata[CellCycledata$Cycling.Score > i-5 & CellCycledata$Cycling.Score <=i,"nUMI"])
  meanUMI <- c(meanUMI, UMI)
}

data <- data.frame(meanUMI= meanUMI,
                   ccPercent= factor(seq(0.05,1, by = 0.05)))

ggplot(data, aes(x=ccPercent, y=meanUMI)) +
        geom_bar(stat = "identity", width = 1)
```


# Session Info

```{r}
#date
format(Sys.time(), "%d %B, %Y, %H,%M")

#Packages used
sessionInfo()
```


